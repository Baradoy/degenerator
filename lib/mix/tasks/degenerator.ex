defmodule Mix.Tasks.Degenerator do
  @moduledoc """
  Create a generator from an existing module.

  """

  use Mix.Task

  @requirements ["app.config"]

  @defaults [
    generator: "generator"
  ]

  def run(args) do
    case OptionParser.parse(args, switches: [name: :string, path: :string, project_root: :string]) do
      {opts, [], []} -> create_generator(opts ++ @defaults)
      _ -> usage()
    end
  end

  def create_generator(opts) do
    opts
    |> build_context_from_opts()
    |> write_module_template()
    |> write_generator_module()
    |> print_shell_results()
  end

  defp usage do
    Mix.shell().info("""
    Usage: mix degenerator path
    """)
  end

  def build_context_from_opts(opts) do
    project_root = Keyword.get(opts, :project_root, File.cwd!())

    module =
      opts
      |> Keyword.fetch!(:module)
      |> String.split(".")
      |> Enum.map(&String.to_atom/1)
      |> Module.safe_concat()

    path = module.__info__(:compile)
      |> Keyword.fetch!(:source)
      |> Path.relative_to(project_root)

    project = module |> Application.get_application() |> to_string

    template_path = String.replace(path, project, "my_project")

    %{
      module: module,
      project_root: project_root,
      path: path,
      template_path: template_path,
      generator: Keyword.fetch!(opts, :generator),
      original_options: opts
    }
  end

  def prewalk({:defmodule, meta, lines}, acc) do
    # Pull basic module info out of the file
    [{:__aliases__, _aliases_meta, [base | scoped] = full_module} | _] = lines

    new_acc =
      acc
      |> Keyword.put(:full_module, full_module)
      |> Keyword.put(:inflection, inflect(scoped))
      |> Keyword.put(:base, base)

    {{:defmodule, meta, lines}, new_acc}
  end

  def prewalk({:moduledoc, moduledoc_meta, moduledoc}, acc) do
    # TODO add generator info to moduledoc
    {{:moduledoc, moduledoc_meta, moduledoc}, acc}
  end

  def prewalk({:__aliases__, aliases_meta, aliases}, acc) do
    acc_aliases = Keyword.get(acc, :aliases, [List.first(aliases)])

    acc_aliases =
      if List.first(aliases) in acc_aliases do
        [List.last(aliases) | acc_aliases]
      else
        acc_aliases
      end

    new_acc = Keyword.put(acc, :aliases, acc_aliases)

    {{:__aliases__, aliases_meta, aliases}, new_acc}
  end

  def prewalk(quoted, acc) do
    {quoted, acc}
  end

  def postwalk({:__aliases__, aliases_meta, aliases}, acc) do
    # Replace the base name and the module name
    project = acc |> Keyword.get(:full_module) |> List.first()
    module = acc |> Keyword.get(:full_module) |> List.last()

    new_aliases =
      aliases
      |> Enum.map(fn
        ^project -> :"<%= project %>"
        ^module -> :"<%= module_name %>"
        section -> section
      end)

    {{:__aliases__, aliases_meta, new_aliases}, acc}
  end

  def postwalk(quoted, acc) do
    {quoted, acc}
  end

  def generator_path(context) do
    "lib/mix/tasks/#{generator_downcase_name(context)}"
  end

  def template_path(context) do
    "priv/templates/#{generator_downcase_name(context)}"
  end

  def generator_module(context) do
    name = Map.fetch!(context, :generator)

    "#{base()}.Gen.#{name}"
    |> String.split(".")
    |> Enum.map(&Macro.camelize/1)
    |> Enum.join(".")
  end

  def base, do: Mix.Phoenix.base()

  def generator_downcase_name(context) do
    context
    |> generator_module()
    |> String.split(".")
    |> Enum.map(&Macro.underscore/1)
    |> Enum.join(".")
  end

  def write_generator_module(context) do
    files = [{:eex, "generator.ex", generator_path(context) <> ".ex"}]

    binding = [
      template_path: Map.fetch!(context, :template_path),
      project: base(),
      name_inflection: context |> Map.fetch!(:generator) |> inflect(),
      module_inflection: Map.fetch!(context, :module_inflection),
      templates_path: template_path(context),
      generator_downcase_name: generator_downcase_name(context),
      app: Mix.Project.config() |> Keyword.fetch!(:app)
    ]

    Mix.Phoenix.copy_from(generator_paths(), "priv/templates/degenerator", binding, files)

    context
  end

  def write_module_template(context) do
    to_quoted_opts = [
      unescape: false,
      warn_on_unnecessary_quotes: false,
      literal_encoder: &{:ok, {:__block__, &2, [&1]}},
      token_metadata: true,
      warnings: false
    ]

    acc = [moduledoc: "This file was generated by running `command`", auxiliary_modules: []]

    {forms, comments} =
      context
      |> Map.fetch!(:path)
      |> File.read!()
      |> Code.string_to_quoted_with_comments!(to_quoted_opts)

    {forms, acc} =
      Macro.traverse(
        forms,
        acc,
        &prewalk/2,
        &postwalk/2
      )

    inflection = Keyword.get(acc, :inflection)
    full_module = Keyword.get(acc, :full_module)

    to_algebra_opts = [comments: comments]
    doc = Code.Formatter.to_algebra(forms, to_algebra_opts)
    source = Inspect.Algebra.format(doc, 98) |> Enum.join()

    target = Path.join(template_path(context), context[:template_path])

    Mix.Generator.create_file(target, source)

    context
    |> Map.put(:module_inflection, inflection)
    |> Map.put(:full_module, full_module)
  end

  def print_shell_results(context) do
    project = context |> Map.get(:full_module) |> List.first()
    module = context |> Map.get(:full_module) |> List.last()

    Mix.shell().info("""

    You can run this generator with:

      > mix #{generator_downcase_name(context)}

    Or pass in options:

      > mix #{generator_downcase_name(context)} --project #{project} --module #{module}

    """)

    context
  end

  defp inflect(aliases) when is_list(aliases) do
    aliases
    |> Enum.map(&Atom.to_string/1)
    |> Enum.join(".")
    |> inflect()
  end

  defp inflect(singular) when is_binary(singular),
    do: singular |> Mix.Phoenix.inflect() |> Map.new()

  defp generator_paths, do: [".", :degenerator]
end
